{"version":3,"sources":["algos/bfs.js"],"names":["bfs","initialize","ctx","walker","mazeConfig","this","end","x","y","nodesLeftInLayer","nodesInNextLayer","rowQueue","colQueue","visitedPaths","endFound","moves","step","shift","foundEnd","cellsToEnqueue","visitAndEnqueueNeighbors","processCells","cells","startingCell","forEach","cell","push","unshift","isSolved","solve","currentCell","shortestPath","length","possiblePath","MazePathController","clearCanvas","drawPath"],"mappings":"+HAAA,mBAEMA,EAAM,CAGRC,WAAY,SAAUC,EAAKC,EAAQC,GAC/BC,KAAKH,IAAMA,EACXG,KAAKF,OAASA,EACdE,KAAKD,WAAaA,EAElBC,KAAKC,IAAM,CAACC,EAAGH,EAAWE,IAAKE,EAAGJ,EAAWE,KAC7CD,KAAKI,iBAAmB,EACxBJ,KAAKK,iBAAmB,EAIxBL,KAAKM,SAAW,CAAC,GACjBN,KAAKO,SAAW,CAAC,GACjBP,KAAKQ,aAAe,GACpBR,KAAKS,UAAW,EAChBT,KAAKU,MAAQ,GAEjBC,KAAM,WACF,IAAIR,EAAIH,KAAKO,SAASK,QAClBV,EAAIF,KAAKM,SAASM,QAElBZ,KAAKa,SAASX,EAAGC,KACjBH,KAAKS,UAAW,GAIpB,IAAIK,EAAiBd,KAAKF,OAAOiB,yBAAyBb,EAAGC,GAC7DH,KAAKgB,aAAaF,EAAgB,CAACZ,EAAGA,EAAGC,EAAGA,IAC5CH,KAAKI,mBAEyB,IAA1BJ,KAAKI,mBACLJ,KAAKI,iBAAmBJ,KAAKK,iBAC7BL,KAAKK,iBAAmB,EACxBL,KAAKU,UAMbM,aAAc,SAASC,EAAOC,GAAe,IAAD,OACxCD,EAAME,QAAQ,SAAAC,GACV,EAAKf,mBACL,EAAKE,SAASc,KAAKD,EAAKjB,GACxB,EAAKG,SAASe,KAAKD,EAAKlB,GACxB,EAAKM,aAAac,QAAQ,CAAC,CAACJ,EAAahB,EAAGgB,EAAaf,GAAI,CAACiB,EAAKlB,EAAGkB,EAAKjB,QAGnFU,SAAU,SAASX,EAAGC,GAClB,OAAOH,KAAKC,IAAIC,IAAMA,GAAKF,KAAKC,IAAIE,IAAMA,GAE9CoB,SAAU,WACN,OAAOvB,KAAKS,UAEhBe,MAAO,WAGH,IAFA,IAAIC,EAAc,CAACzB,KAAKC,IAAIC,EAAGF,KAAKC,IAAIE,GACpCuB,EAAe,CAACD,GACbzB,KAAKQ,aAAamB,OAAS,GAAG,CACjC,IAAIC,EAAe5B,KAAKQ,aAAaI,QACjCgB,EAAa,GAAG,KAAOH,EAAY,IACnCG,EAAa,GAAG,KAAOH,EAAY,KAC/BA,EAAcG,EAAa,GAC3BF,EAAaJ,QAAQM,EAAa,KAI9CC,IAAmBC,cACnB9B,KAAKF,OAAOiC,SAASL,KAId/B","file":"static/js/4.86e36ff8.chunk.js","sourcesContent":["import MazePathController from '../controller/mazeController';\n\nconst bfs = {\n    // Walker will track:\n    //      visited\n    initialize: function (ctx, walker, mazeConfig) {\n        this.ctx = ctx;\n        this.walker = walker;\n        this.mazeConfig = mazeConfig;\n        // For 10-path x 10-path maze\n        this.end = {x: mazeConfig.end, y: mazeConfig.end};\n        this.nodesLeftInLayer = 1; // our start\n        this.nodesInNextLayer = 0;\n\n        // Instead of storing a pair of coords in a single array, which requires a wrapper and a lot of unpacking\n        //  We can store each dimension in a separate array\n        this.rowQueue = [0];\n        this.colQueue = [0];\n        this.visitedPaths = [];\n        this.endFound = false;\n        this.moves = 0;\n    },\n    step: function () {\n        let y = this.colQueue.shift(),\n            x = this.rowQueue.shift();\n\n        if (this.foundEnd(x, y)) {\n            this.endFound = true;\n            // maybe return here?\n        }\n\n        let cellsToEnqueue = this.walker.visitAndEnqueueNeighbors(x, y);\n        this.processCells(cellsToEnqueue, {x: x, y: y});\n        this.nodesLeftInLayer--;\n\n        if (this.nodesLeftInLayer === 0) {\n            this.nodesLeftInLayer = this.nodesInNextLayer;\n            this.nodesInNextLayer = 0;\n            this.moves++;\n            // iterate step count here if we want the length of the shortest path\n            // if we want EVERY step taken, do it in process cells\n\n        }\n    },\n    processCells: function(cells, startingCell) {\n        cells.forEach(cell => {\n            this.nodesInNextLayer++;\n            this.colQueue.push(cell.y);\n            this.rowQueue.push(cell.x);\n            this.visitedPaths.unshift([[startingCell.x, startingCell.y], [cell.x, cell.y]]);\n        });\n    },\n    foundEnd: function(x, y,) {\n        return this.end.x === x && this.end.y === y\n    },\n    isSolved: function() {\n        return this.endFound;\n    },\n    solve: function() {\n        let currentCell = [this.end.x, this.end.y],\n            shortestPath = [currentCell];\n        while (this.visitedPaths.length > 0) {\n            let possiblePath = this.visitedPaths.shift();\n            if (possiblePath[1][0] === currentCell[0] &&\n                possiblePath[1][1] === currentCell[1]) {\n                    currentCell = possiblePath[0];\n                    shortestPath.unshift(possiblePath[0]);\n            }\n        };\n\n        MazePathController.clearCanvas();\n        this.walker.drawPath(shortestPath);\n    }\n};\n\nexport default bfs;"],"sourceRoot":""}