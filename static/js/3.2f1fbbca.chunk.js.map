{"version":3,"sources":["algos/aStar.js"],"names":["aStar","initialize","ctx","walker","mazeConfig","this","start","GraphNode","GraphNodeType","OPEN","end","openHeap","generateHeap","push","initializeVisited","step","search","currentNode","itemCount","pop","closed","x","y","getAStarNeighbors","forEach","neighbor","movementCostToNeighbor","gCost","cost","previouslyVisited","visited","g","parent","hCost","manhattan","fCost","ActionCreator","updateItem","draw","shadeMap","maze","length","point","isOpen","WALL","BinaryHeap","a","b","Math","abs","isSolved","solve","currentCell","shortestPath","unshift","MazePathController","clearCanvas","drawPath","type","scoreFunction","items","el","sortUp","splice","sortDown","node","includes","indexOf","n","leftChildIndex","rightChildIndex","swapIndex","i","parentItem","parentIndex","floor"],"mappings":"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","file":"static/js/3.2f1fbbca.chunk.js","sourcesContent":["import MazePathController from '../controller/mazeController';\nimport * as ActionCreator from '../actions/action-creator';\n\nconst aStar = {\n    initialize: function (ctx, walker, mazeConfig) {\n        this.ctx = ctx;\n        this.walker = walker;\n        this.mazeConfig = mazeConfig;\n        this.start = new GraphNode(mazeConfig.start, mazeConfig.start, GraphNodeType.OPEN);\n        this.end = new GraphNode(mazeConfig.end, mazeConfig.end, GraphNodeType.OPEN);\n        this.openHeap = this.generateHeap();\n        this.openHeap.push(this.start);\n        this.initializeVisited();\n    },\n    step: function () {\n        this.search();\n    },\n    search: function () {\n        let currentNode,\n            currentNodeNeighbors;\n\n        if (this.openHeap.itemCount > 0) {\n            currentNode = this.openHeap.pop()\n            currentNode.closed = true;\n            this.walker.x = currentNode.x;\n            this.walker.y = currentNode.y;\n            currentNodeNeighbors = this.walker.getAStarNeighbors(currentNode.x, currentNode.y);\n\n            currentNodeNeighbors.forEach(neighbor => {\n                let movementCostToNeighbor = currentNode.gCost + neighbor.cost,\n                    previouslyVisited = neighbor.visited;\n\n                if (movementCostToNeighbor < neighbor.g || !previouslyVisited) {\n                    neighbor.visited = true;\n                    neighbor.parent = currentNode;\n                    neighbor.gCost = movementCostToNeighbor;\n                    neighbor.hCost = this.manhattan([neighbor.x, neighbor.y], [this.end.x, this.end.y]);\n                    neighbor.fCost = neighbor.gCost + neighbor.hCost;\n                    this.walker.visited[neighbor.y][neighbor.x] = neighbor;\n                    ActionCreator.iterateSteps();\n                    // If we've already visited then we rescored an el and need to update it\n                    if (!previouslyVisited) {\n                        this.openHeap.push(neighbor);\n                        this.walker.draw(neighbor.x, neighbor.y, this.walker.shadeMap[1]);\n                    } else {\n                        this.openHeap.updateItem(neighbor);\n                    }\n                }\n            })\n        }\n    },\n    initializeVisited: function () {\n        // Iterate through maze from mazeConfig, updating walker.visited[y][x] to GraphNodes\n        for (let y = 0; y < this.walker.maze.length; y++) {\n            for (let x = 0; x < this.walker.maze.length; x++) {\n                let point = {x: x, y: y};\n                this.walker.visited[y][x] = new GraphNode(x, y, (this.walker.isOpen(point) ? GraphNodeType.OPEN : GraphNodeType.WALL));\n            }\n        }\n    },\n    generateHeap: function () {\n        // generate a heap with our score function\n        return new BinaryHeap(function (a, b) {\n            if (a.fCost < b.fCost) return 1;\n            if (a.fCost > b.fCost) return -1;\n            return 0;\n        })\n    },\n    // http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html\n    manhattan: function (a, b) {\n        let d1 = Math.abs(b[0] - a[0]),\n            d2 = Math.abs(b[1] - a[1]);\n        return d1 + d2;\n    },\n    isSolved: function () {\n        return (this.walker.x === this.end.x && this.walker.y === this.end.y);\n    },\n    solve: function () {\n        let currentCell = this.walker.visited[this.end.y][this.end.x],\n            shortestPath = [[currentCell.x, currentCell.y]];\n        while (true) {\n            if (shortestPath[0][0] === this.start.x && shortestPath[0][1] === this.start.y) {\n                break;\n            } else {\n                currentCell = currentCell.parent;\n                shortestPath.unshift([currentCell.x, currentCell.y]);\n            }\n        }\n        MazePathController.clearCanvas();\n        this.walker.drawPath(shortestPath);\n    }\n}\n\nconst GraphNodeType = { OPEN: 1, WALL: 0}\n\nclass GraphNode {\n    constructor(x, y, type) {\n        this.x = x;\n        this.y = y;\n        this.gCost = 0;\n        this.hCost = 0;\n        this.fCost = 0;\n        this.cost = 10;\n        this.visited = false;\n        this.closed = false;\n        this.parent = null;\n        this.type = type;\n    }\n}\n\n// Lower F-costs have a HIGHER priority and are thusly organized higher in the tree\nclass BinaryHeap {\n    constructor(scoreFunction) {\n        this.scoreFunction = scoreFunction;\n        this.items = [];\n        this.itemCount = 0;\n    }\n\n    push(el) {\n        // Add el to the heap\n        this.items[this.itemCount]= el;\n        this.itemCount++;\n        this.sortUp(this.itemCount - 1);\n    }\n\n    pop() {\n        // Remove top of heap\n        let el = this.items[0];\n        this.itemCount--;\n        // Property of heap, adding last-most el to top of heap\n        this.items[0] = this.items[this.itemCount];\n        // this.items = this.items.splice(-1, 1);\n        this.items.splice(-1, 1);\n        this.sortDown(0);\n        return el;\n    }\n\n    count() {\n        return this.itemCount;\n    }\n\n    contains(node) {\n        return this.items.includes(node);\n    }\n\n    updateItem(node) {\n        this.sortUp(this.items.indexOf(node))\n    }\n\n    sortDown(n) {\n        let el = this.items[n],\n            leftChildIndex,\n            rightChildIndex,\n            swapIndex;\n\n        while (true) {\n            leftChildIndex = n * 2 + 1;\n            rightChildIndex = n * 2 + 2;\n            // If there is a left child\n            if (leftChildIndex < this.itemCount) {\n                swapIndex = leftChildIndex;\n\n                // If there is a right child\n                if (rightChildIndex < this.itemCount) {\n                    // If left child has a HIGHER f-cost than right child\n                    if (this.scoreFunction(this.items[leftChildIndex], this.items[rightChildIndex]) < 0) {\n                        swapIndex = rightChildIndex;\n                    }\n                }\n\n                if (this.scoreFunction(el, this.items[swapIndex]) < 0) {\n                    this.items[n] = this.items[swapIndex];\n                    this.items[swapIndex] = el;\n                    n = swapIndex;\n                } else {\n                    // correct position found, return\n                    return;\n                }\n            } else {\n                // no more children, also in correct position\n                return;\n            }\n        }\n    }\n    sortUp(i) {\n        let el = this.items[i],\n        // Property of heap; subtract 1 to accomodate for 0 index\n        // https://www.cs.cmu.edu/~adamchik/15-121/lectures/Binary%20Heaps/heaps.html\n            parentIndex = Math.floor(i / 2),\n            parentItem;\n        while (true) {\n            parentItem = this.items[parentIndex];\n\n            if (this.scoreFunction(el, parentItem) > 0) {\n                this.items[parentIndex] = el;\n                this.items[i] = parentItem;\n            } else {\n                break;\n            }\n            i = parentIndex // update position of el\n            if (parentIndex > 0) {\n                parentIndex = Math.floor((i - 1) / 2); // calc new parent index\n            }\n        }\n    }\n}\n\nexport default aStar;"],"sourceRoot":""}