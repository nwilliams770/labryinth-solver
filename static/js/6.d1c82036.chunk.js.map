{"version":3,"sources":["algos/wallFollower.js"],"names":["wallFollower","initialize","ctx","walker","mazeConfig","this","end","x","y","currentDirection","Math","PI","step","point","canMoveLeft","moveWithWall","rotateLeftNinety","canMoveForward","canMoveRight","rotateRightNinety","backTrack","theta","relativeBackwardTileVector","rotate","relativeLeftTileVector","relativeLeftTile","outOfBounds","isOpen","relativeForwardTileVector","relativeForwardTile","relativeRightTileVector","relativeRightTile","matrix","cos","sin","x1","y1","round","isSolved","solve","MazePathController","clearCanvas","drawPathFromStack"],"mappings":"+HAAA,mBAUMA,EAAe,CAEjBC,WAAY,SAAUC,EAAKC,EAAQC,GAC/BC,KAAKH,IAAMA,EACXG,KAAKF,OAASA,EACdE,KAAKD,WAAaA,EAElBC,KAAKC,IAAM,CAACC,EAAGH,EAAWE,IAAKE,EAAGJ,EAAWE,KAC7CD,KAAKI,iBAAmB,IAAMC,KAAKC,IAEvCC,KAAM,WACF,IAAIC,EAAQR,KAAKS,YAAYT,KAAKI,kBAE9BI,IACAR,KAAKF,OAAOY,aAAaF,GACzBR,KAAKW,qBAITH,EAAQR,KAAKY,eAAeZ,KAAKI,mBAE7BJ,KAAKF,OAAOY,aAAaF,IAIzBA,EAAQR,KAAKa,aAAab,KAAKI,oBAE3BJ,KAAKF,OAAOY,aAAaF,GACzBR,KAAKc,sBAELN,EAAQR,KAAKe,YACbf,KAAKF,OAAOY,aAAaF,GAEzBR,KAAKW,mBACLX,KAAKW,qBAIjBI,UAAW,WAEP,IAEIC,EAAQhB,KAAKI,iBACba,EAA6BjB,KAAKkB,QAH7B,EACD,EAE2CF,GAE/C,MADuB,CAACd,EAAGF,KAAKF,OAAOI,EAAIe,EAA2B,GAAId,EAAGH,KAAKF,OAAOK,EAAIc,EAA2B,KAGhIR,YAAa,WAET,IAEIO,EAAQhB,KAAKI,iBACbe,EAAyBnB,KAAKkB,OAH1B,GACC,EAEsCF,GAC3CI,EAAmB,CAAClB,EAAIF,KAAKF,OAAOI,EAAIiB,EAAuB,GAAIhB,EAAGH,KAAKF,OAAOK,EAAIgB,EAAuB,IAGjH,QADenB,KAAKF,OAAOuB,YAAYD,KAAqBpB,KAAKF,OAAOwB,OAAOF,KAAqBA,GAGxGR,eAAgB,WAEZ,IAEII,EAAQhB,KAAKI,iBACbmB,EAA4BvB,KAAKkB,OAH7B,EACA,EAE0CF,GAC9CQ,EAAsB,CAACtB,EAAGF,KAAKF,OAAOI,EAAIqB,EAA0B,GAAIpB,EAAGH,KAAKF,OAAOK,EAAIoB,EAA0B,IAGrH,QADevB,KAAKF,OAAOuB,YAAYG,KAAwBxB,KAAKF,OAAOwB,OAAOE,KAAwBA,GAGlHX,aAAc,WAEV,IAEIG,EAAQhB,KAAKI,iBACbqB,EAA0BzB,KAAKkB,OAH3B,EACA,EAEwCF,GAC5CU,EAAoB,CAACxB,EAAGF,KAAKF,OAAOI,EAAIuB,EAAwB,GAAItB,EAAGH,KAAKF,OAAOK,EAAIsB,EAAwB,IAG/G,QADezB,KAAKF,OAAOuB,YAAYK,KAAsB1B,KAAKF,OAAOwB,OAAOI,KAAsBA,GAG9GR,OAAQ,SAAUhB,EAAGC,EAAGa,GAIpB,IAAIW,EAAS,CACL,CAAGtB,KAAKuB,IAAIZ,GAAQX,KAAKwB,IAAIb,IAC7B,EAAGX,KAAKwB,IAAIb,GAAQX,KAAKuB,IAAIZ,KAEjCc,EAAM5B,EAAIyB,EAAO,GAAG,GAAOxB,EAAIwB,EAAO,GAAG,GACzCI,EAAM7B,EAAIyB,EAAO,GAAG,GAAOxB,EAAIwB,EAAO,GAAG,GAE7C,MAAO,CAACtB,KAAK2B,MAAMF,GAAKzB,KAAK2B,MAAMD,KAGvCpB,iBAAkB,WAEdX,KAAKI,kBAAoBJ,KAAKI,iBAAoBC,KAAKC,GAAK,IAAS,EAAID,KAAKC,KAElFQ,kBAAmB,WAEfd,KAAKI,kBAAoBJ,KAAKI,iBAAoBC,KAAKC,GAAK,EAAQ,EAAID,KAAKC,KAAQ,EAAID,KAAKC,KAElG2B,SAAU,WACN,OAAQjC,KAAKF,OAAOI,IAAMF,KAAKC,IAAIC,GAAKF,KAAKF,OAAOK,IAAMH,KAAKC,IAAIE,GAEvE+B,MAAO,WAEHC,IAAmBC,cACnBpC,KAAKF,OAAOuC,sBAIL1C","file":"static/js/6.d1c82036.chunk.js","sourcesContent":["import MazePathController from '../controller/mazeController';\n\n// We are using a rotation matrix to determine the relative directions no matter which direction\n// Because we are rotating about our own walker as opposed to the origin, our vector size is of length 1\n// We are also using a kind of zero-point mechanism to determine how many degrees for our rotation matrix\n    // East: 0 degrees\n    // North: 90 degrees\n    // West: 180 degrees\n    // South: 270 degrees\n\nconst wallFollower = {\n    // In this implementation, leaning towards the left\n    initialize: function (ctx, walker, mazeConfig) {\n        this.ctx = ctx;\n        this.walker = walker;\n        this.mazeConfig = mazeConfig;\n        // For 10-path x 10-path maze\n        this.end = {x: mazeConfig.end, y: mazeConfig.end};\n        this.currentDirection = 1.5 * Math.PI; // we want to start facing South e.g 270 deg;\n    },\n    step: function () {\n        let point = this.canMoveLeft(this.currentDirection);\n        // Move left anytime we can\n        if (point) {\n            this.walker.moveWithWall(point);\n            this.rotateLeftNinety();\n        }\n\n        // Move forward if possible\n        point = this.canMoveForward(this.currentDirection);\n        if (point) {\n            this.walker.moveWithWall(point);\n        } else {\n            // If we can't move left or forward, we may be in some corner where we can only turn right\n            // But if we can't turn right, we're in a deadend and need to turn around\n            point = this.canMoveRight(this.currentDirection);\n            if (point) {\n                this.walker.moveWithWall(point);\n                this.rotateRightNinety();\n            } else {\n                point = this.backTrack();\n                this.walker.moveWithWall(point);\n                // Do a 180\n                this.rotateLeftNinety();\n                this.rotateLeftNinety();\n            }\n        }\n    },\n    backTrack: function () {\n        // Backward at 0 deg is x -1\n        let x = -1,\n            y = 0,\n            theta = this.currentDirection,\n            relativeBackwardTileVector = this.rotate(x, y, theta), // coordinates for the relative left tile\n            relativeBackwardTile = {x: this.walker.x + relativeBackwardTileVector[0], y: this.walker.y + relativeBackwardTileVector[1]};\n            return relativeBackwardTile;\n    },\n    canMoveLeft: function () {\n        // Left at 0 deg is y -1\n        let x = 0,\n            y = -1,\n            theta = this.currentDirection,\n            relativeLeftTileVector = this.rotate(x, y, theta), // coordinates for the relative left tile\n            relativeLeftTile = {x:  this.walker.x + relativeLeftTileVector[0], y: this.walker.y + relativeLeftTileVector[1]}\n\n        let result = (!this.walker.outOfBounds(relativeLeftTile) && this.walker.isOpen(relativeLeftTile)) ? relativeLeftTile : false;\n        return result;\n    },\n    canMoveForward: function () {\n        // Forward at 0 deg is x + 1\n        let x = 1,\n            y = 0,\n            theta = this.currentDirection,\n            relativeForwardTileVector = this.rotate(x, y, theta), // coordinates for the relative forward tile\n            relativeForwardTile = {x: this.walker.x + relativeForwardTileVector[0], y: this.walker.y + relativeForwardTileVector[1]};\n\n            let result = (!this.walker.outOfBounds(relativeForwardTile) && this.walker.isOpen(relativeForwardTile)) ? relativeForwardTile : false;\n            return result;\n    },\n    canMoveRight: function () {\n        // Right at 0 deg is y + 1\n        let x = 0,\n            y = 1,\n            theta = this.currentDirection,\n            relativeRightTileVector = this.rotate(x, y, theta), // coordinates for the relative right tile\n            relativeRightTile = {x: this.walker.x + relativeRightTileVector[0], y: this.walker.y + relativeRightTileVector[1]};\n\n            let result = (!this.walker.outOfBounds(relativeRightTile) && this.walker.isOpen(relativeRightTile)) ? relativeRightTile : false;\n            return result;\n    },\n    rotate: function (x, y, theta) {\n    // rotation matrix\n    // https://en.wikipedia.org/wiki/Rotation_matrix\n\n        let matrix = [\n                [  Math.cos(theta), Math.sin(theta)],\n                [ -Math.sin(theta), Math.cos(theta)]\n            ],\n            x1 = (x * matrix[0][0]) + (y * matrix[0][1]),\n            y1 = (x * matrix[1][0]) + (y * matrix[1][1]);\n\n        return [Math.round(x1), Math.round(y1)];\n\n    },\n    rotateLeftNinety: function () {\n        // Add 90 deg then wrap to 360 for debugging purposes\n        this.currentDirection = (this.currentDirection + (Math.PI / 2.0)) % (2 * Math.PI);\n    },\n    rotateRightNinety: function () {\n        // Subtract 90 deg then wrap to 360 for debugging purposes\n        this.currentDirection = (this.currentDirection - (Math.PI / 2.0) + (2 * Math.PI)) % (2 * Math.PI);\n    },\n    isSolved: function() {\n        return (this.walker.x === this.end.x && this.walker.y === this.end.y);\n    },\n    solve: function() {\n        // this.walker.removeColor([201,64,133]);\n        MazePathController.clearCanvas();\n        this.walker.drawPathFromStack();\n    }\n};\n\nexport default wallFollower;"],"sourceRoot":""}